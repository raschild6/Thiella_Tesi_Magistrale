%!TEX root = ../dissertation.tex
\chapter{Appendix A} \label{AppendixA}

\section{PDDL Problem and Domain}\label{sec:PDDL} 

\begin{footnotesize}
\textbf{Code in PDDL notation:} Description of the problem as a definition of the domain, objects, initial state (INIT) and goal. \\
In this example: four blocks (A, B, C, D) are arranged independently on the table and the robot's hand is free. The goal is a stack formed by the four blocks placed in reverse alphabetical order (D on C on B on A).
\end{footnotesize}

\begin{python}
(define (problem BLOCKS-4-0)
	(:domain BLOCKS)
	(:objects D B A C - block)
	(:INIT (CLEAR C) (CLEAR A) (CLEAR B) (CLEAR D) 
		(ONTABLE C) (ONTABLE A) (ONTABLE B) 
		(ONTABLE D) (HANDEMPTY))
	(:goal (AND (ON D C) (ON C B) (ON B A)))
)
\end{python}

\bigskip

\begin{footnotesize}
\textbf{Code in PDDL notation:} Description of the domain, concerning the problem above, as all possible actions and \enquote{predicates} available. \\
Predicates are the \enquote{states} in which one or more objects can be. Actions, takeable by the robot, are described as input parameters, preconditions for performing that action and effects once the action is completed. 
\end{footnotesize}

\begin{python}
(define (domain BLOCKS)
  (:requirements :strips :typing)
  (:types block)
  (:predicates (on ?x - block ?y - block)
	       (ontable ?x - block)
	       (clear ?x - block)
	       (handempty)
	       (holding ?x - block)
	       )

  (:action pick-up
	     :parameters (?x - block)
	     :precondition (and (clear ?x) (ontable ?x) 
  			     (handempty))
	     :effect
	     (and (not (ontable ?x))
		   (not (clear ?x))
		   (not (handempty))
		   (holding ?x)))

  (:action put-down
	     :parameters (?x - block)
	     :precondition (holding ?x)
	     :effect
	     (and (not (holding ?x))
		   (clear ?x)
		   (handempty)
		   (ontable ?x)))
  (:action stack
	     :parameters (?x - block ?y - block)
	     :precondition (and (holding ?x) (clear ?y))
	     :effect
	     (and (not (holding ?x))
		   (not (clear ?y))
		   (clear ?x)
		   (handempty)
		   (on ?x ?y)))
  (:action unstack
	     :parameters (?x - block ?y - block)
	     :precondition (and (on ?x ?y) (clear ?x) 
			     (handempty))
	     :effect
	     (and (holding ?x)
		   (clear ?y)
		   (not (clear ?x))
		   (not (handempty))
		   (not (on ?x ?y)))))
\end{python}


\section{Knowledge Base examples}\label{sec:KB_examples} 

\begin{footnotesize}
\textbf{Code in Atomese notation:} \\
Starting with the simplest arrangement of objects: there is a table and there is an apple, a banana and a tray on it. Then, first the objects and their inheritances are defined, next the objects are differentiated, and finally, as they are all on top of the table, the \textit{clear} status is associated with each of them. \\
\end{footnotesize}

\begin{python}
	(InheritanceLink
		(ConceptNode "apple")
		(ConceptNode "object"))
	(InheritanceLink
		(ConceptNode "banana")
		(ConceptNode "object"))
	(InheritanceLink
		(ConceptNode "tray")
		(ConceptNode "object"))
	(InheritanceLink
		(ConceptNode "table")
		(ConceptNode "fixed-object"))

	(NotLink (EqualLink 
		(ConceptNode "apple") (ConceptNode "banana")))
	(NotLink (EqualLink 
		(ConceptNode "apple") (ConceptNode "tray")))
	(NotLink (EqualLink 
		(ConceptNode "apple") (ConceptNode "table")))
	(NotLink (EqualLink 
		(ConceptNode "banana") (ConceptNode "tray")))
	(NotLink (EqualLink 
		(ConceptNode "banana") (ConceptNode "table")))
	(NotLink (EqualLink 
		(ConceptNode "tray") (ConceptNode "table")))
	
	(EvaluationLink
		(PredicateNode "clear")
		(ConceptNode "apple"))
	(EvaluationLink
		(PredicateNode "clear")
		(ConceptNode "banana"))
	(EvaluationLink
		(PredicateNode "clear")
		(ConceptNode "tray"))
	(EvaluationLink
		(PredicateNode "clear")
		(ConceptNode "table"))
\end{python}

Fixed objects do not lose their \textit{clear} state when an object is placed on top of them, as is the case of the other objects. However, this state is maintained as long as there is room to place a new object, otherwise it is removed and the fixed object will result completely busy. \\
Furthermore, notice how there are no states related to the fact that the objects are on top of the table. This is because the actions of \textit{Pickup} and \textit{Putdown} have been maintained. The table is considered as the main working plane, so these actions will be executed within the objects above it. \\
In general, these actions can be used on objects that are on top of fixed objects in the initial situation, so for example, \textit{Pickup} will not require to know what is under the object to pick up, it will just pick it up. \textit{Putdown}, on the other hand, is used to put down an object in a generic position, it is not important where. This action is rarely used. \\
However, all four actions are maintained and used to speed up the first actions and simplify the initial knowledge base.\\

To conclude, suppose now that the apple is on the tray and the banana is in the hand. InheritanceLinks and NotLinks are the same as the code above and will always remain unchanged once created, within each execution of the algorithm, thus they are omitted below. The knowledge base will become as follows: \\

\begin{python}	
	(EvaluationLink
		(PredicateNode "clear")
		(ConceptNode "apple"))
	(EvaluationLink
		(PredicateNode "in-hand")
		(ConceptNode "banana"))
	(EvaluationLink
		(PredicateNode "on")
		(ListLink
			(ConceptNode "apple")
			(ConceptNode "tray"))
	(EvaluationLink
		(PredicateNode "clear")
		(ConceptNode "table"))
\end{python}